import { Entity, Id } from "@rbxts/jecs";
import { CovenantHooks } from "./hooks";
import { Remove, Delete } from "./stringEnums";
export * from "@rbxts/jecs";
export type WorldChangesForReplication = Map<string, Delete | Map<string, defined | Remove>>;
export type WorldChangesForPrediction = Map<string, Map<string, defined | Remove>>;
export type LoggingOption = "FORCE_ON" | "FORCE_OFF" | "COMPONENT_CONTROLLED";
export interface CovenantProps {
    logging: LoggingOption;
    requestPayloadSend: () => void;
    requestPayloadConnect: (callback: (player: Player) => void) => void;
    replicationSend: (player: Player, worldChanges: WorldChangesForReplication) => void;
    replicationSendAll?: (worldChanges: WorldChangesForReplication) => void;
    replicationConnect: (callback: (worldChanges: WorldChangesForReplication) => void) => void;
    predictionSend: (worldChanges: WorldChangesForPrediction) => void;
    predictionConnect: (callback: (player: Player, worldChanges: WorldChangesForPrediction) => void) => void;
}
type ComponentSubscriber<T extends defined = defined> = (entity: Entity, state: T | undefined, previousState: T | undefined, isDeleting: boolean) => void;
type ComponentPredictionValidator = (player: Player, entity: Entity, newState: unknown, lastState: unknown) => boolean;
export declare class Covenant {
    private _world;
    private systems;
    private worldChangesForReplication;
    private worldChangesForPrediction;
    private stringfiedComponents;
    private undefinedStringifiedComponents;
    private replicatedStringifiedComponents;
    private predictedStringifiedComponents;
    private loggingStringfiedComponents;
    private stringfiedComponentsToNameMap;
    private started;
    private stringifiedComponentSubscribers;
    private stringifiedComponentValidators;
    private clientToServerEntityMap;
    private serverToClientEntityMap;
    private requestPayloadSend;
    private requestPayloadConnect;
    private replicationSend;
    private replicationConnect;
    private replicationSendAll;
    private predictionSend;
    private predictionConnect;
    constructor({ logging, requestPayloadSend, requestPayloadConnect, replicationSend, replicationConnect, replicationSendAll, predictionSend, predictionConnect, }: CovenantProps);
    getClientEntity(entity: Entity): Entity | undefined;
    getServerEntity(entity: Entity): Entity | undefined;
    private loggingOption;
    private setupPredictionClient;
    private forEachComponentChanges;
    private setupPredictionServer;
    private setupPrediction;
    private setupReplicationServer;
    private setupReplicationPayload;
    private setupReplicationClient;
    private setupReplication;
    start(): void;
    private preventPostStartCall;
    private schedule;
    private worldSet;
    subscribeComponent<T extends defined>(component: Entity<T>, subscriber: ComponentSubscriber<T>): () => void;
    private worldDelete;
    worldComponent<T extends defined>(name: string): Entity<T>;
    getComponentName(component: Entity): string;
    worldTag(): Entity<undefined>;
    private checkComponentDefined;
    private defineComponentNetworkBehavior;
    defineComponent<T extends defined>({ logging, component, queriedComponents, recipe, replicated, predictionValidator, }: {
        logging?: true;
        replicated: boolean;
        predictionValidator: ComponentPredictionValidator | false;
        component: Entity<T>;
        queriedComponents: Entity[][];
        recipe: (entity: Entity, lastState: T | undefined, updateId: number, hooks: CovenantHooks) => T | undefined;
    }): void;
    defineIdentity<T extends defined>({ logging, identityComponent, replicated, lifetime, factory, }: {
        logging?: true;
        identityComponent: Entity<T>;
        replicated: boolean;
        lifetime: (entity: Entity, state: T, despawn: () => void) => (() => void) | undefined;
        factory: (spawnEntity: (state: T) => void) => void;
    }): void;
    private worldEntity;
    worldQuery<T extends Id[]>(...components: T): import("@rbxts/jecs").Query<T>;
    worldHas(entity: Entity, ...components: Id[]): boolean;
    worldGet<T extends [Id] | [Id, Id] | [Id, Id, Id] | [Id, Id, Id, Id]>(entity: Entity, ...components: T): import("@rbxts/jecs").FlattenTuple<[...import("@rbxts/jecs").Nullable<import("@rbxts/jecs").InferComponents<T>>]>;
    worldContains(entity: Entity): boolean;
}
